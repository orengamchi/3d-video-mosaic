<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>פסיפס וידאו תלת-ממדי</title>
  <style>
    /* General page and body styling */
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      overflow: hidden;
      background: #000;
      touch-action: none; /* Disable touch actions like pinch-zoom */
      user-select: none; /* Disable text selection */
      font-family: system-ui, sans-serif;
    }
    /* Canvas and video positioning */
    #three-canvas, video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    video { z-index: 1; opacity: 0; /* Hidden but accessible for processing */ }
    #three-canvas { z-index: 2; background: #000; }
    
    /* Control panel styling */
    .control-panel {
      position: fixed;
      z-index: 10;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      padding: 10px;
      border-radius: 15px;
      display: flex;
      gap: 15px;
      align-items: center;
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* Main controls at the bottom-center */
    #controls {
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      flex-direction: row;
      padding: 10px 15px;
    }

    /* Camera switch button styling */
    #camera-switch {
      top: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      padding: 0;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      border-radius: 50%;
    }
    #camera-switch:active { background: rgba(0, 0, 0, 0.5); }
    
    /* Controls container for toggling */
    #main-controls {
        display: flex;
        align-items: center;
        gap: 15px;
        transition: all 0.5s ease;
    }

    /* Hidden state for main controls */
    #main-controls.hidden {
        max-width: 0;
        opacity: 0;
        overflow: hidden;
        padding: 0;
        margin: 0;
        gap: 0;
    }

    /* Form element styling */
    label { font-weight: 500; margin-bottom: 4px; font-size: 14px; text-align: center;}
    input, select, .control-button { 
        cursor: pointer;
        background: rgba(255,255,255,0.1);
        color: white;
        border: 1px solid rgba(255,255,255,0.3);
        border-radius: 8px;
        padding: 5px;
        font-family: system-ui, sans-serif;
    }
    
    /* Styling for individual control items */
    .control-item-col {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .control-item-col input[type="range"] {
        width: 100px;
    }

    #toggleControlsBtn {
      font-size: 20px;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
    }
    
    /* Shape Selector styles */
    #shape-selector {
        position: relative;
    }
    #shape-options {
        display: flex;
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%) scale(0.9);
        background: rgba(20, 20, 20, 0.7);
        backdrop-filter: blur(10px);
        padding: 8px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        gap: 8px;
        margin-bottom: 10px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
    }
    #shape-selector.expanded #shape-options {
        opacity: 1;
        pointer-events: auto;
        transform: translateX(-50%) scale(1);
    }
    .shape-btn {
        padding: 8px;
        background: transparent;
        border: 1px solid transparent;
        opacity: 0.7;
    }
    .shape-btn:hover {
        opacity: 1;
        background: rgba(255,255,255,0.1);
    }
    .shape-btn svg {
        display: block;
        width: 20px;
        height: 20px;
    }
    #current-shape-btn {
        padding: 8px;
    }

    /* --- New Signature Styles --- */
    .signature {
        position: fixed;
        bottom: 10px;
        color: rgba(255, 255, 255, 0.5);
        font-size: 12px;
        z-index: 9;
        pointer-events: none;
    }
    #signature-left {
        left: 15px;
    }
    #signature-right {
        right: 15px;
    }

  </style>
</head>
<body>
  <!-- Video element to capture camera stream -->
  <video id="video" autoplay playsinline muted></video>
 
  <!-- Main control panel for effects -->
  <div id="controls" class="control-panel">
    <div id="main-controls" class="hidden">
        <div class="control-item-col">
            <label for="densitySlider">צפיפות</label>
            <input type="range" id="densitySlider" min="5" max="35" value="25" title="צפיפות">
        </div>
        
        <div class="control-item-col">
            <label>צורה</label>
            <div id="shape-selector">
                <button id="current-shape-btn" class="control-button" title="שנה צורה"></button>
                <div id="shape-options">
                    <button class="shape-btn control-button" data-shape="box" title="קובייה">
                        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 4.5H19.5V19.5H4.5V4.5M6 6V18H18V6H6Z"></path></svg>
                    </button>
                    <button class="shape-btn control-button" data-shape="sphere" title="כדור">
                        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 2A10 10 0 1 0 22 12A10 10 0 0 0 12 2Z"></path></svg>
                    </button>
                    <button class="shape-btn control-button" data-shape="hexagon" title="משושה">
                        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M17.16 4.42L12 2L6.84 4.42L4.26 9.58L6.84 14.74L12 17.16L17.16 14.74L19.74 9.58L17.16 4.42Z"></path></svg>
                    </button>
                    <button class="shape-btn control-button" data-shape="nail" title="מסמר">
                        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M13.6 2.6L12.19 4L13.6 5.41L14.21 4.79L15.62 6.2L14.21 7.61L15.62 9L14.21 10.41L15.62 11.82L14.21 13.24L15.62 14.65L14.21 16.06L15.62 17.47L12.83 20.27L11.41 18.85L18.41 11.85L13.6 7.03L11.41 9.22L10 7.81L11.41 6.39L10 4.97L11.41 3.56L10 2.15L11.41 0.73L13.6 2.6Z"></path></svg>
                    </button>
                    <button class="shape-btn control-button" data-shape="cone" title="חרוט">
                        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 2L4 22H20L12 2Z"></path></svg>
                    </button>
                    <button class="shape-btn control-button" data-shape="torus" title="טורוס">
                        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 6A6 6 0 1 0 18 12A6 6 0 0 0 12 6M12 4A8 8 0 1 1 4 12A8 8 0 0 1 12 4Z"></path></svg>
                    </button>
                </div>
            </div>
        </div>

        <div class="control-item-col">
            <label for="forceSlider">תזוזה</label>
            <input type="range" id="forceSlider" min="1" max="25" value="8" step="0.5" title="תזוזה">
        </div>
        <div class="control-item-col">
            <label for="depthSlider">עומק</label>
            <input type="range" id="depthSlider" min="0.1" max="50" value="15" step="0.5" title="עומק">
        </div>
    </div>
    <button id="toggleControlsBtn" class="control-button" title="הצג/הסתר תפריט">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </button>
  </div>
  
  <!-- Button to switch between front and back cameras -->
  <button id="camera-switch" class="control-panel" title="החלף מצלמה">🔄</button>
  
  <!-- Signature elements -->
  <div id="signature-left" class="signature">BY Oren Gamchi</div>
  <div id="signature-right" class="signature">BY Oren Gamchi</div>

  <!-- Third-party libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>

  <script>
    // --- Global constants and variables ---
    let GRID_DENSITY = 20, MOTION_THRESHOLD = 20, EXPLOSION_FORCE = 8, SHAPE_DEPTH = 15;
    const RESTORE_SPEED = 0.03, DAMPING = 0.90;
    const ROTATION_FORCE = 0.2, ROTATIONAL_DAMPING = 0.95;

    // DOM element references
    const video = document.getElementById('video'),
          cameraSwitchBtn = document.getElementById('camera-switch'),
          densitySlider = document.getElementById('densitySlider'),
          forceSlider = document.getElementById('forceSlider'),
          depthSlider = document.getElementById('depthSlider'),
          toggleControlsBtn = document.getElementById('toggleControlsBtn'),
          mainControls = document.getElementById('main-controls'),
          shapeSelector = document.getElementById('shape-selector'),
          currentShapeBtn = document.getElementById('current-shape-btn'),
          shapeOptions = document.getElementById('shape-options');
   
    // Offscreen canvas for video processing
    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });

    // State variables
    let shapes = [], prevFrameData = null, currentStream,
        currentFacingMode = 'environment',
        currentShape = 'box',
        worldWidth, worldHeight, grid;

    // --- Three.js setup ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
   
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.id = 'three-canvas';
    document.body.appendChild(renderer.domElement);

    // Orbit controls for camera manipulation
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.z = 400;
    controls.update();

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(20, 20, 50);
    directionalLight.castShadow = true;
    camera.add(directionalLight);
    scene.add(camera);

    // --- Core functions ---

    /**
     * Creates the cyber grid floor.
     */
    function createFloor() {
        grid = new THREE.GridHelper(1000, 100, 0xffffff, 0xffffff);
        const colors = new Float32Array(grid.geometry.attributes.position.count * 3);
        grid.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        grid.material = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.3 });
        scene.add(grid);
    }

    /**
     * Sets up the camera stream.
     * @param {string} facingMode - 'user' for front camera, 'environment' for back camera.
     */
    async function setupCamera(facingMode) {
      if (currentStream) currentStream.getTracks().forEach(track => track.stop());
      try {
        currentStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: facingMode } });
        video.srcObject = currentStream;
        video.onloadedmetadata = () => {
          video.play();
          GRID_DENSITY = 40 - parseInt(densitySlider.value);
          resizeAndInit();
        };
      } catch (e) {
        if (facingMode === 'environment') {
            currentFacingMode = 'user';
            setupCamera('user');
        } else {
            alert('לא ניתן לגשת למצלמה.');
        }
      }
    }
    
    /**
     * Recalculates world dimensions and re-initializes shapes.
     */
    function resizeAndInit() {
      const aspectRatio = video.videoWidth / video.videoHeight || 16/9;
      if (window.innerWidth / window.innerHeight > aspectRatio) {
        worldHeight = 500;
        worldWidth = worldHeight * aspectRatio;
      } else {
        worldWidth = 500;
        worldHeight = worldWidth / aspectRatio;
      }
      initShapes();
    }

    /**
     * Creates a geometry based on the current shape selection.
     */
    function createGeometry() {
        const size = GRID_DENSITY * 0.9;
        switch(currentShape) {
            case 'sphere': return new THREE.SphereGeometry(size / 2, 16, 12);
            case 'cone': return new THREE.ConeGeometry(size / 2, size * 1.5, 20);
            case 'torus': return new THREE.TorusGeometry(size * 0.3, size * 0.15, 16, 24);
            case 'hexagon':
                const hexGeo = new THREE.CylinderGeometry(size / 2, size / 2, SHAPE_DEPTH, 6);
                hexGeo.rotateX(Math.PI / 2);
                return hexGeo;
            case 'nail':
                const head = new THREE.CylinderGeometry(size * 0.4, size * 0.4, SHAPE_DEPTH * 0.1, 12);
                head.translate(0, SHAPE_DEPTH * 0.5, 0);
                const shaft = new THREE.CylinderGeometry(size * 0.1, size * 0.1, SHAPE_DEPTH, 12);
                const nailGeo = THREE.BufferGeometryUtils.mergeBufferGeometries([head, shaft]);
                nailGeo.rotateX(Math.PI / 2);
                return nailGeo;
            case 'box': default: return new THREE.BoxGeometry(size, size, SHAPE_DEPTH);
        }
    }
   
    /**
     * Clears existing shapes and creates a new grid of shapes.
     */
    function initShapes() {
        // Clear old shapes
        shapes.forEach(s => { scene.remove(s); s.geometry.dispose(); s.material.dispose(); });
        shapes = [];

        const geometry = createGeometry();
        const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7, metalness: 0.1 });
        
        const borderSize = 10;
        const gridW = Math.round(worldWidth / GRID_DENSITY);
        const gridH = Math.round(worldHeight / GRID_DENSITY);
        offscreenCanvas.width = gridW;
        offscreenCanvas.height = gridH;
        
        const totalGridW = gridW + borderSize * 2;
        const totalGridH = gridH + borderSize * 2;
        const totalWorldWidth = totalGridW * GRID_DENSITY;
        const totalWorldHeight = totalGridH * GRID_DENSITY;

        grid.position.y = - (totalWorldHeight / 2) - 50;
        
        for (let y = 0; y < totalGridH; y++) {
            for (let x = 0; x < totalGridW; x++) {
                const isVideoShape = (x >= borderSize && x < gridW + borderSize && y >= borderSize && y < gridH + borderSize);
                let originX, originY;
                const isHexGrid = currentShape === 'hexagon';

                if (isHexGrid) {
                    const hexWidth = GRID_DENSITY;
                    const hexHeight = (Math.sqrt(3) / 2) * hexWidth;
                    originX = ((totalGridW - 1 - x) * hexWidth) - (totalWorldWidth / 2);
                    if (y % 2 !== 0) { originX += hexWidth / 2; }
                    originY = -(y * hexHeight) + (totalWorldHeight / 2);
                } else {
                    originX = ((totalGridW - 1 - x) * GRID_DENSITY) - (totalWorldWidth / 2);
                    originY = -(y * GRID_DENSITY) + (totalWorldHeight / 2);
                }
                
                const shapeMaterial = material.clone();
                if (!isVideoShape) shapeMaterial.color.set(0x1a1a1a);

                const shape = new THREE.Mesh(geometry, shapeMaterial);
                shape.castShadow = true;
                shape.receiveShadow = true;
                shape.position.set(originX, originY, 0);
                shape.userData = { 
                    originPosition: shape.position.clone(), 
                    velocity: new THREE.Vector3(0, 0, 0),
                    rotationalVelocity: new THREE.Vector3(0, 0, 0),
                    originalQuaternion: shape.quaternion.clone(),
                    isVideoShape: isVideoShape
                };

                if (isVideoShape) {
                    shape.userData.dataIndex = ((y - borderSize) * gridW + (x - borderSize)) * 4;
                }

                shapes.push(shape);
                scene.add(shape);
            }
        }
        
        prevFrameData = null;
    }

    /**
     * The main animation loop.
     */
    function animationLoop() {
      requestAnimationFrame(animationLoop);
      const time = Date.now() * 0.0005;
      
      const color1 = new THREE.Color().setHSL(time % 1, 0.7, 0.5);
      const color2 = new THREE.Color().setHSL((time + 0.3) % 1, 0.8, 0.5);
      const colors = grid.geometry.attributes.color.array;
      for (let i = 0; i < colors.length; i += 3) {
          const color = (i % 6 === 0) ? color1 : color2;
          colors[i] = color.r;
          colors[i + 1] = color.g;
          colors[i + 2] = color.b;
      }
      grid.geometry.attributes.color.needsUpdate = true;
      
      if (video.readyState >= 4) updateVideoState(); 
      updatePhysics();
      controls.update();
      renderer.render(scene, camera);
    }
   
    /**
     * Updates the physics for each shape.
     */
    function updatePhysics() {
        for (const shape of shapes) {
            const restoreForce = shape.userData.originPosition.clone().sub(shape.position).multiplyScalar(RESTORE_SPEED);
            shape.userData.velocity.add(restoreForce).multiplyScalar(DAMPING);
            shape.position.add(shape.userData.velocity);
            const deltaRotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(shape.userData.rotationalVelocity.x, shape.userData.rotationalVelocity.y, shape.userData.rotationalVelocity.z));
            shape.quaternion.multiplyQuaternions(deltaRotation, shape.quaternion);
            shape.quaternion.slerp(shape.userData.originalQuaternion, RESTORE_SPEED * 2);
            shape.userData.rotationalVelocity.multiplyScalar(ROTATIONAL_DAMPING);
        }
    }

    /**
     * Processes video, detects motion, and updates shapes.
     */
    function updateVideoState() {
      offscreenCtx.save();
      if (currentFacingMode === 'user') {
        offscreenCtx.scale(-1, 1);
        offscreenCtx.translate(-offscreenCanvas.width, 0);
      }
      offscreenCtx.drawImage(video, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
      offscreenCtx.restore();

      const currentFrameData = offscreenCtx.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height).data;

      if (prevFrameData) {
        for (const shape of shapes) {
          if (!shape.userData.isVideoShape) continue;
          const dataIndex = shape.userData.dataIndex;
          const r = currentFrameData[dataIndex];
          const g = currentFrameData[dataIndex + 1];
          const b = currentFrameData[dataIndex + 2];
          shape.material.color.setRGB(r / 255, g / 255, b / 255);
          const diff = Math.abs(r - prevFrameData[dataIndex]) + Math.abs(g - prevFrameData[dataIndex+1]) + Math.abs(b - prevFrameData[dataIndex+2]);
          if (diff > MOTION_THRESHOLD) {
            shape.userData.velocity.z -= EXPLOSION_FORCE;
            shape.userData.rotationalVelocity.add(new THREE.Vector3((Math.random()-0.5)*ROTATION_FORCE, (Math.random()-0.5)*ROTATION_FORCE, (Math.random()-0.5)*ROTATION_FORCE));
          }
        }
      }
      prevFrameData = currentFrameData;
    }

    /**
     * Sets the current shape icon on the main button.
     */
    function updateCurrentShapeIcon() {
        const shapeButton = shapeOptions.querySelector(`.shape-btn[data-shape="${currentShape}"]`);
        if (shapeButton) {
            currentShapeBtn.innerHTML = shapeButton.innerHTML;
        }
    }

    // --- Event Listeners ---
    cameraSwitchBtn.addEventListener('click', () => {
      currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
      setupCamera(currentFacingMode);
    });
    densitySlider.addEventListener('input', () => { GRID_DENSITY = 40 - parseInt(densitySlider.value); resizeAndInit(); });
    forceSlider.addEventListener('input', (e) => EXPLOSION_FORCE = parseFloat(e.target.value));
    depthSlider.addEventListener('input', (e) => { SHAPE_DEPTH = parseFloat(e.target.value); resizeAndInit(); });
    toggleControlsBtn.addEventListener('click', () => mainControls.classList.toggle('hidden'));
    
    // Shape selector listeners
    currentShapeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        shapeSelector.classList.toggle('expanded');
    });

    shapeOptions.addEventListener('click', (e) => {
        const button = e.target.closest('.shape-btn');
        if (!button) return;
        currentShape = button.dataset.shape;
        updateCurrentShapeIcon();
        resizeAndInit();
        shapeSelector.classList.remove('expanded');
    });

    window.addEventListener('click', () => {
        if (shapeSelector.classList.contains('expanded')) {
            shapeSelector.classList.remove('expanded');
        }
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        resizeAndInit();
    });

    // --- Initial setup ---
    createFloor();
    updateCurrentShapeIcon();
    setupCamera(currentFacingMode);
    animationLoop();
  </script>
</body>
</html>
