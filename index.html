<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>פסיפס וידאו תלת-ממדי</title>
  <style>
    /* General page and body styling */
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      overflow: hidden;
      background: #000;
      touch-action: none;
      user-select: none;
      font-family: system-ui, sans-serif;
    }
    /* Canvas and video positioning */
    #three-canvas, video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    video { 
        z-index: 1; 
        opacity: 0;
        /* Flip the video element for a mirror effect on the front camera */
        transform: scaleX(-1);
    }
    #three-canvas { z-index: 2; background: transparent; }
    
    /* Control panel base styling */
    .control-panel {
      position: fixed;
      z-index: 10;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(8px);
      padding: 10px 15px;
      border-radius: 15px;
      display: flex;
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: opacity 0.5s ease-in-out, transform 0.3s ease-in-out;
    }
    
    /* Desktop Controls Panel */
    #controls {
      top: 20px;
      right: 20px;
      flex-direction: column;
      align-items: stretch;
      width: 240px;
      gap: 12px;
      padding-top: 30px;
    }

    /* Shared button styling */
    .icon-button {
      width: 50px;
      height: 50px;
      padding: 0;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      cursor: pointer;
      border-radius: 50%;
    }
    .icon-button:active { background: rgba(0, 0, 0, 0.5); }

    #camera-switch {
      top: 20px;
      left: 20px;
    }
    
    /* Hide icon button (desktop) */
    #hide-icon-btn {
        position: absolute;
        top: 8px;
        left: 8px;
        width: 24px;
        height: 24px;
        background: rgba(0,0,0,0.4);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 20px;
        line-height: 24px;
        font-weight: bold;
    }
    #hide-icon-btn:hover { background: rgba(255,255,255,0.3); }

    /* Form element styling */
    label { font-weight: 500; margin-left: 5px; }
    input, select, button.control-button { 
        cursor: pointer;
        background: rgba(255,255,255,0.1);
        color: white;
        border: 1px solid rgba(255,255,255,0.3);
        border-radius: 5px;
        padding: 8px;
        font-family: system-ui, sans-serif;
        width: 100%;
        box-sizing: border-box;
    }
    button.control-button.active {
        background: rgba(80, 150, 255, 0.5);
        border-color: rgba(80, 150, 255, 0.8);
    }
    
    .control-item-col { display: flex; flex-direction: column; gap: 5px; }
    hr { border: none; border-top: 1px solid rgba(255, 255, 255, 0.2); width: 100%; margin: 5px 0; }
    
    #signature {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: rgba(255, 255, 255, 0.5);
        font-size: 16px;
        z-index: 10;
        pointer-events: none;
    }

    .hidable { opacity: 1; }
    .hidden { opacity: 0 !important; pointer-events: none; }

    #loading-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.7); color: white; z-index: 999;
        display: flex; justify-content: center; align-items: center;
        font-size: 1.5em; backdrop-filter: blur(5px);
    }

    /* --- Mobile Specific Styles --- */
    #menu-toggle { display: none; }

    @media (max-width: 768px) {
        #controls {
            width: 260px;
            height: 100%;
            top: 0;
            right: 0;
            border-radius: 0;
            transform: translateX(100%);
            justify-content: center;
        }
        #controls.is-open {
            transform: translateX(0);
        }
        #hide-icon-btn { display: none; } /* Hide desktop 'x' */

        #menu-toggle {
            display: flex; /* Show hamburger */
            position: fixed;
            bottom: 20px;
            right: 20px;
        }
        #camera-switch {
            top: auto;
            left: 20px;
            bottom: 20px;
        }
        #signature {
            bottom: 80px; /* Move up to avoid buttons */
        }
    }
  </style>
</head>
<body>
  <div id="loading-overlay" class="hidden"><div>טוען מודל בינה מלאכותית...</div></div>
  <video id="video" autoplay playsinline muted></video>
 
  <div id="controls" class="control-panel hidable">
    <div id="hide-icon-btn" title="הסתר תפריט">×</div>
    <div class="control-item-col">
        <label for="densitySlider">צפיפות:</label>
        <input type="range" id="densitySlider" min="5" max="35" value="25">
    </div>
    <div class="control-item-col">
        <label for="shapeSelect">צורה:</label>
        <select id="shapeSelect">
            <option value="box">קובייה</option>
            <option value="sphere">כדור</option>
            <option value="hexagon">משושה</option>
            <option value="nail">מסמר</option>
            <option value="cone">חרוט</option>
            <option value="torus">טורוס</option>
        </select>
    </div>
    <div class="control-item-col">
        <label for="forceSlider">תזוזה:</label>
        <input type="range" id="forceSlider" min="1" max="25" value="8" step="0.5">
    </div>
    <div class="control-item-col">
        <label for="depthSlider">עומק:</label>
        <input type="range" id="depthSlider" min="0.1" max="50" value="15" step="0.5">
    </div>
    <hr>
    <button id="selfieModeBtn" class="control-button">👤 מצב סלפי</button>
  </div>
  
  <button id="camera-switch" class="control-panel hidable icon-button" title="החלף מצלמה">🔄</button>
  <button id="menu-toggle" class="control-panel hidable icon-button" title="פתח תפריט">☰</button>
  <div id="signature" class="hidable">BY Oren Gamchi</div>

  <!-- Third-party libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>

  <script>
    // --- Global constants and variables ---
    let GRID_DENSITY = 20, MOTION_THRESHOLD = 20, EXPLOSION_FORCE = 8, SHAPE_DEPTH = 15;
    const SEGMENTATION_THRESHOLD = 0.95; // Highest sensitivity, hardcoded
    const RESTORE_SPEED = 0.03, DAMPING = 0.90;
    const ROTATION_FORCE = 0.2, ROTATIONAL_DAMPING = 0.95;

    // DOM element references
    const video = document.getElementById('video'), 
          cameraSwitchBtn = document.getElementById('camera-switch'),
          controlsPanel = document.getElementById('controls'),
          densitySlider = document.getElementById('densitySlider'),
          shapeSelect = document.getElementById('shapeSelect'), 
          forceSlider = document.getElementById('forceSlider'),
          depthSlider = document.getElementById('depthSlider'),
          hideIconBtn = document.getElementById('hide-icon-btn'),
          selfieModeBtn = document.getElementById('selfieModeBtn'),
          menuToggleBtn = document.getElementById('menu-toggle'),
          loadingOverlay = document.getElementById('loading-overlay');
   
    // Canvases for video processing
    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
    const segmentationCanvas = document.createElement('canvas');
    const segmentationCtx = segmentationCanvas.getContext('2d', { willReadFrequently: true });

    // State variables
    let shapes = [], prevFrameData = null, currentFacingMode = 'environment', currentStream,
        currentShape = 'box', hideControlsTimeout, worldWidth, worldHeight, grid,
        isSelfieMode = false, selfieSegmenter, isModelReady = false,
        isVideoProcessingLoopRunning = false;

    // --- Three.js setup ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.domElement.id = 'three-canvas';
    document.body.appendChild(renderer.domElement);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.z = 400;
    controls.update();
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(20, 20, 50);
    directionalLight.castShadow = true;
    camera.add(directionalLight);
    scene.add(camera);

    // --- Core functions ---
    
    function initializeSegmentation() {
        selfieSegmenter = new SelfieSegmentation({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`});
        selfieSegmenter.setOptions({ modelSelection: 0 }); 
        selfieSegmenter.onResults(onSegmentationResults);
    }

    function createFloor() {
        grid = new THREE.GridHelper(1000, 100, 0xffffff, 0xffffff);
        grid.material.opacity = 0.3;
        grid.material.transparent = true;
        scene.add(grid);
    }

    function updateBackground() {
        grid.visible = !isSelfieMode;
        renderer.setClearAlpha(isSelfieMode ? 0 : 1);
    }

    async function setupCamera(facingMode) {
      if (currentStream) currentStream.getTracks().forEach(track => track.stop());
      try {
        currentStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: facingMode } });
        video.srcObject = currentStream;
        video.onloadedmetadata = () => {
          video.play();
          GRID_DENSITY = 40 - parseInt(densitySlider.value);
          resizeAndInit();
          if (!isVideoProcessingLoopRunning) {
              isVideoProcessingLoopRunning = true;
              videoProcessingLoop();
          }
        };
      } catch (e) {
        if (facingMode === 'environment') setupCamera('user');
        else alert('לא ניתן לגשת למצלמה.');
      }
    }

    function hideControls() {
        document.querySelectorAll('.hidable').forEach(c => c.classList.add('hidden'));
    }

    function showAndResetTimer() {
        document.querySelectorAll('.hidable').forEach(c => c.classList.remove('hidden'));
        clearTimeout(hideControlsTimeout);
        hideControlsTimeout = setTimeout(hideControls, 5000);
    }

    function resizeAndInit() {
      const aspectRatio = video.videoWidth / video.videoHeight || 16/9;
      worldHeight = 500;
      worldWidth = window.innerWidth > window.innerHeight ? worldHeight * aspectRatio : worldHeight / aspectRatio;
      initShapes();
    }

    function createGeometry() {
        const size = GRID_DENSITY * 0.9;
        switch(currentShape) {
            case 'sphere': return new THREE.SphereGeometry(size / 2, 16, 12);
            case 'cone': return new THREE.ConeGeometry(size / 2, size * 1.5, 20);
            case 'torus': return new THREE.TorusGeometry(size * 0.3, size * 0.15, 16, 24);
            case 'hexagon':
                const hexGeo = new THREE.CylinderGeometry(size / 2, size / 2, SHAPE_DEPTH, 6);
                hexGeo.rotateX(Math.PI / 2);
                return hexGeo;
            case 'nail':
                const head = new THREE.CylinderGeometry(size * 0.4, size * 0.4, SHAPE_DEPTH * 0.1, 12);
                head.translate(0, SHAPE_DEPTH * 0.5, 0);
                const shaft = new THREE.CylinderGeometry(size * 0.1, size * 0.1, SHAPE_DEPTH, 12);
                const nailGeo = THREE.BufferGeometryUtils.mergeBufferGeometries([head, shaft]);
                nailGeo.rotateX(Math.PI / 2);
                return nailGeo;
            case 'box': default: return new THREE.BoxGeometry(size, size, SHAPE_DEPTH);
        }
    }
   
    function initShapes() {
        shapes.forEach(s => { scene.remove(s); s.geometry.dispose(); s.material.dispose(); });
        shapes = [];
        const geometry = createGeometry();
        const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7, metalness: 0.1 });
        
        const borderSize = 10;
        const gridW = Math.round(worldWidth / GRID_DENSITY);
        const gridH = Math.round(worldHeight / GRID_DENSITY);
        [offscreenCanvas.width, segmentationCanvas.width] = [gridW, gridW];
        [offscreenCanvas.height, segmentationCanvas.height] = [gridH, gridH];
        
        const totalGridW = gridW + borderSize * 2;
        const totalGridH = gridH + borderSize * 2;
        const totalWorldWidth = totalGridW * GRID_DENSITY;
        const totalWorldHeight = totalGridH * GRID_DENSITY;

        if (grid) grid.position.y = - (totalWorldHeight / 2) - 50;
        
        for (let y = 0; y < totalGridH; y++) {
            for (let x = 0; x < totalGridW; x++) {
                const isVideoShape = (x >= borderSize && x < gridW + borderSize && y >= borderSize && y < gridH + borderSize);
                let originX, originY;
                if (currentShape === 'hexagon') {
                    const hexWidth = GRID_DENSITY, hexHeight = (Math.sqrt(3) / 2) * hexWidth;
                    originX = ((totalGridW - 1 - x) * hexWidth) - (totalWorldWidth / 2);
                    if (y % 2 !== 0) originX += hexWidth / 2;
                    originY = -(y * hexHeight) + (totalWorldHeight / 2);
                } else {
                    originX = ((totalGridW - 1 - x) * GRID_DENSITY) - (totalWorldWidth / 2);
                    originY = -(y * GRID_DENSITY) + (totalWorldHeight / 2);
                }
                
                const shapeMaterial = material.clone();
                if (!isVideoShape) shapeMaterial.color.set(0x1a1a1a);

                const shape = new THREE.Mesh(geometry, shapeMaterial);
                shape.castShadow = true;
                shape.receiveShadow = true;
                shape.position.set(originX, originY, 0);
                shape.userData = { 
                    originPosition: shape.position.clone(), 
                    velocity: new THREE.Vector3(), rotationalVelocity: new THREE.Vector3(),
                    originalQuaternion: shape.quaternion.clone(), isVideoShape: isVideoShape
                };
                if (isVideoShape) {
                    shape.userData.dataIndex = ((y - borderSize) * gridW + (x - borderSize)) * 4;
                }
                shapes.push(shape);
                scene.add(shape);
            }
        }
        prevFrameData = null;
    }

    function animationLoop() {
      requestAnimationFrame(animationLoop);
      const time = Date.now() * 0.0005;
      
      if (grid && grid.visible) {
        grid.material.color.setHSL(time % 1, 0.7, 0.5);
      }
      
      updatePhysics();
      controls.update();
      renderer.render(scene, camera);
    }
   
    function updatePhysics() {
        for (const shape of shapes) {
            if (!shape.visible) continue;
            shape.userData.velocity.add(shape.userData.originPosition.clone().sub(shape.position).multiplyScalar(RESTORE_SPEED));
            shape.userData.velocity.multiplyScalar(DAMPING);
            shape.position.add(shape.userData.velocity);
            const deltaRotation = new THREE.Quaternion().setFromEuler(new THREE.Euler().setFromVector3(shape.userData.rotationalVelocity));
            shape.quaternion.multiplyQuaternions(deltaRotation, shape.quaternion);
            shape.quaternion.slerp(shape.userData.originalQuaternion, RESTORE_SPEED * 2);
            shape.userData.rotationalVelocity.multiplyScalar(ROTATIONAL_DAMPING);
        }
    }
    
    async function videoProcessingLoop() {
        if (video.readyState >= 2) {
            await selfieSegmenter.send({image: video});
        }
        requestAnimationFrame(videoProcessingLoop);
    }

    function onSegmentationResults(results) {
        if (!isModelReady) {
            isModelReady = true;
            loadingOverlay.classList.add('hidden');
        }
        
        offscreenCtx.drawImage(results.image, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
        const currentFrameData = offscreenCtx.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height).data;

        if (isSelfieMode) {
            shapes.forEach(s => { if(s.userData.isVideoShape) s.visible = false; });
            segmentationCtx.drawImage(results.segmentationMask, 0, 0, segmentationCanvas.width, segmentationCanvas.height);
            const maskData = segmentationCtx.getImageData(0, 0, segmentationCanvas.width, segmentationCanvas.height).data;

            for (const shape of shapes) {
                if (!shape.userData.isVideoShape) continue;
                if (maskData[shape.userData.dataIndex] / 255 > SEGMENTATION_THRESHOLD) {
                    shape.visible = true;
                    updateShapeAppearance(shape, currentFrameData);
                }
            }
        } else {
            shapes.forEach(s => {
                if(s.userData.isVideoShape) {
                    s.visible = true;
                    updateShapeAppearance(s, currentFrameData);
                }
            });
        }
        prevFrameData = currentFrameData;
    }

    function updateShapeAppearance(shape, frameData) {
        let [r, g, b] = [frameData[shape.userData.dataIndex], frameData[shape.userData.dataIndex + 1], frameData[shape.userData.dataIndex + 2]];
        shape.material.color.setRGB(r / 255, g / 255, b / 255);

        if (prevFrameData) {
            const diff = Math.abs(r - prevFrameData[shape.userData.dataIndex]) + Math.abs(g - prevFrameData[shape.userData.dataIndex+1]) + Math.abs(b - prevFrameData[shape.userData.dataIndex+2]);
            if (diff > MOTION_THRESHOLD) {
                shape.userData.velocity.add(new THREE.Vector3(0, 0, -EXPLOSION_FORCE));
                shape.userData.rotationalVelocity.add(new THREE.Vector3((Math.random()-0.5)*ROTATION_FORCE, (Math.random()-0.5)*ROTATION_FORCE, (Math.random()-0.5)*ROTATION_FORCE));
            }
        }
    }

    // --- Event Listeners ---
    cameraSwitchBtn.addEventListener('click', () => {
      currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
      video.style.transform = (currentFacingMode === 'user') ? 'scaleX(-1)' : 'scaleX(1)';
      setupCamera(currentFacingMode);
    });
    selfieModeBtn.addEventListener('click', () => {
        isSelfieMode = !isSelfieMode;
        selfieModeBtn.classList.toggle('active', isSelfieMode);
        if (!isModelReady) loadingOverlay.classList.remove('hidden');
        shapes.forEach(s => { if(!s.userData.isVideoShape) s.visible = !isSelfieMode; });
        updateBackground();
    });
    densitySlider.addEventListener('input', () => { GRID_DENSITY = 40 - parseInt(densitySlider.value); resizeAndInit(); });
    shapeSelect.addEventListener('change', (e) => { currentShape = e.target.value; resizeAndInit(); });
    forceSlider.addEventListener('input', (e) => EXPLOSION_FORCE = parseFloat(e.target.value));
    depthSlider.addEventListener('input', (e) => { SHAPE_DEPTH = parseFloat(e.target.value); resizeAndInit(); });
    hideIconBtn.addEventListener('click', hideControls);
    menuToggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        controlsPanel.classList.toggle('is-open');
    });
    document.body.addEventListener('click', () => {
        if (controlsPanel.classList.contains('is-open')) {
            controlsPanel.classList.remove('is-open');
        }
    });
    controlsPanel.addEventListener('click', (e) => e.stopPropagation());

    window.addEventListener('pointerdown', showAndResetTimer);
    window.addEventListener('pointermove', showAndResetTimer);
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        resizeAndInit();
    });

    // --- Initial setup ---
    initializeSegmentation();
    createFloor();
    updateBackground();
    setupCamera(currentFacingMode);
    showAndResetTimer();
    animationLoop();
  </script>
</body>
</html>
