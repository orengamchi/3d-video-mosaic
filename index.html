<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>驻住驻住  注 住 专 住专</title>
  <style>
    /* General page and body styling */
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      overflow: hidden;
      background: #000;
      touch-action: none; /* Disable touch actions like pinch-zoom */
      user-select: none; /* Disable text selection */
      font-family: system-ui, sans-serif;
    }
    /* Canvas and video positioning */
    #three-canvas, video, .processing-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    video, .processing-canvas { z-index: 1; opacity: 0; pointer-events: none; /* Hidden but accessible */ }
    #three-canvas { z-index: 2; background: transparent; }
    
    /* Control panel styling */
    .control-panel {
      position: fixed;
      z-index: 10;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 10px;
      border-radius: 15px;
      display: flex;
      gap: 15px;
      align-items: center;
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* Main controls at the bottom-center */
    #controls {
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      flex-direction: row;
      padding: 10px 15px;
      transition: bottom 0.3s ease; /* Added for smooth transition */
    }

    /* Mobile-specific adjustment for controls position */
    @media (max-width: 768px) {
      #controls {
        bottom: 30px; /* Raised by 10px for better mobile usability */
      }
    }

    /* Camera switch button styling */
    #camera-switch {
      top: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      padding: 0;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      border-radius: 50%;
    }
    #camera-switch:active { background: rgba(0, 0, 0, 0.5); }
    
    /* Controls container for toggling */
    #main-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        transition: all 0.5s ease;
    }

    /* Hidden state for main controls */
    #main-controls.hidden {
        max-width: 0;
        opacity: 0;
        overflow: hidden;
        padding: 0;
        margin: 0;
        gap: 0;
    }

    /* Form element styling */
    label { font-weight: 500; margin-bottom: 4px; font-size: 14px; text-align: center;}
    input, select, .control-button { 
        cursor: pointer;
        background: rgba(255,255,255,0.1);
        color: white;
        border: 1px solid rgba(255,255,255,0.3);
        border-radius: 8px;
        padding: 5px;
        font-family: system-ui, sans-serif;
    }
    select option { background: #333; color: white; }
    
    /* Styling for individual control items */
    .control-item-col {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .control-item-col input[type="range"] {
        width: 80px;
    }

    #toggleControlsBtn {
      font-size: 20px;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
    }
    
    /* Shape Selector styles */
    #shape-selector {
        position: relative;
    }
    #shape-options {
        display: flex;
        flex-wrap: wrap;
        width: 240px; /* Wider to accommodate more icons */
        justify-content: center;
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%) scale(0.9);
        background: rgba(20, 20, 20, 0.7);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        padding: 8px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        gap: 8px;
        margin-bottom: 10px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
    }
    #shape-selector.expanded #shape-options {
        opacity: 1;
        pointer-events: auto;
        transform: translateX(-50%) scale(1);
    }
    .shape-btn {
        padding: 8px;
        background: transparent;
        border: 1px solid transparent;
        opacity: 0.7;
    }
    .shape-btn:hover {
        opacity: 1;
        background: rgba(255,255,255,0.1);
    }
    .shape-btn svg {
        display: block;
        width: 20px;
        height: 20px;
    }
    #current-shape-btn {
        padding: 8px;
    }

    #recordBtn.recording {
        background-color: #ff4136;
        animation: pulse 1s infinite;
    }
    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(255, 65, 54, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(255, 65, 54, 0); }
        100% { box-shadow: 0 0 0 0 rgba(255, 65, 54, 0); }
    }

    /* Signature Styles */
    .signature {
        position: fixed;
        bottom: 10px;
        color: rgba(255, 255, 255, 0.5);
        font-size: 12px;
        z-index: 9;
        pointer-events: none;
    }
    #signature-left {
        left: 15px;
    }
    #signature-right {
        right: 15px;
    }

  </style>
</head>
<body>
  <!-- Video element to capture camera stream -->
  <video id="video" autoplay playsinline muted></video>
  <canvas id="segmentation-canvas" class="processing-canvas"></canvas>
 
  <!-- Main control panel for effects -->
  <div id="controls" class="control-panel">
    <div id="main-controls" class="hidden">
        <div class="control-item-col">
            <label for="densitySlider">爪驻驻转</label>
            <input type="range" id="densitySlider" min="5" max="35" value="25" title="爪驻驻转">
        </div>
        
        <div class="control-item-col">
            <label>爪专</label>
            <div id="shape-selector">
                <button id="current-shape-btn" class="control-button" title="砖 爪专"></button>
                <div id="shape-options">
                    <button class="shape-btn control-button" data-shape="box" title="拽"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 4.5H19.5V19.5H4.5V4.5M6 6V18H18V6H6Z"></path></svg></button>
                    <button class="shape-btn control-button" data-shape="sphere" title="专"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 2A10 10 0 1 0 22 12A10 10 0 0 0 12 2Z"></path></svg></button>
                    <button class="shape-btn control-button" data-shape="cone" title="专"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 2L4 22H20L12 2Z"></path></svg></button>
                    <button class="shape-btn control-button" data-shape="torus" title="专住"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 6A6 6 0 1 0 18 12A6 6 0 0 0 12 6M12 4A8 8 0 1 1 4 12A8 8 0 0 1 12 4Z"></path></svg></button>
                    <button class="shape-btn control-button" data-shape="cylinder" title=""><svg viewBox="0 0 24 24"><path fill="currentColor" d="M12,2C9.24,2 7,4.24 7,7V17C7,19.76 9.24,22 12,22C14.76,22 17,19.76 17,17V7C17,4.24 14.76,2 12,2Z"></path></svg></button>
                    <button class="shape-btn control-button" data-shape="tetrahedron" title="驻专"><svg viewBox="0 0 24 24"><path fill="currentColor" d="m12 2l-10 18h20l-10-18zm0 4.63l5.18 9.37h-10.36l5.18-9.37z"></path></svg></button>
                    <button class="shape-btn control-button" data-shape="octahedron" title="拽专"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 2L2 12L12 22L22 12L12 2Z"></path></svg></button>
                    <button class="shape-btn control-button" data-shape="dodecahedron" title="拽专"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 2.5L5.5 7L2 15.5L8.5 20L15.5 20L22 15.5L18.5 7L12 2.5Z"></path></svg></button>
                    <button class="shape-btn control-button" data-shape="icosahedron" title="拽住专"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 1L2 9L12 23L22 9L12 1Z"></path></svg></button>
                    <button class="shape-btn control-button" data-shape="nail" title="住专"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M13.6 2.6L12.19 4L13.6 5.41L14.21 4.79L15.62 6.2L14.21 7.61L15.62 9L14.21 10.41L15.62 11.82L14.21 13.24L15.62 14.65L14.21 16.06L15.62 17.47L12.83 20.27L11.41 18.85L18.41 11.85L13.6 7.03L11.41 9.22L10 7.81L11.41 6.39L10 4.97L11.41 3.56L10 2.15L11.41 0.73L13.6 2.6Z"></path></svg></button>
                </div>
            </div>
        </div>

        <div class="control-item-col">
            <label for="forceSlider">转</label>
            <input type="range" id="forceSlider" min="1" max="50" value="20" step="1" title="转">
        </div>
        <div class="control-item-col">
            <label for="depthSlider">注 爪专</label>
            <input type="range" id="depthSlider" min="0.1" max="50" value="15" step="0.5" title="注 爪专">
        </div>
        <button id="recordBtn" class="control-button" title="拽"></button>
    </div>
    <button id="toggleControlsBtn" class="control-button" title="爪/住转专 转驻专">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </button>
  </div>
  
  <!-- Button to switch between front and back cameras -->
  <button id="camera-switch" class="control-panel" title="祝 爪"></button>
  
  <!-- Signature elements -->
  <div id="signature-left" class="signature">BY Oren Gamchi</div>
  <div id="signature-right" class="signature">BY Oren Gamchi</div>

  <!-- Third-party libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>

  <script>
    // --- Global constants and variables ---
    let GRID_DENSITY = 20, EXPLOSION_FORCE = 20, SHAPE_DEPTH = 15, MOTION_THRESHOLD = 20;
    const RESTORE_SPEED = 0.05, DAMPING = 0.85;
    const ROTATION_FORCE = 0.2, ROTATIONAL_DAMPING = 0.95;

    // DOM element references
    const video = document.getElementById('video'),
          cameraSwitchBtn = document.getElementById('camera-switch'),
          densitySlider = document.getElementById('densitySlider'),
          forceSlider = document.getElementById('forceSlider'),
          depthSlider = document.getElementById('depthSlider'),
          toggleControlsBtn = document.getElementById('toggleControlsBtn'),
          mainControls = document.getElementById('main-controls'),
          shapeSelector = document.getElementById('shape-selector'),
          currentShapeBtn = document.getElementById('current-shape-btn'),
          shapeOptions = document.getElementById('shape-options'),
          recordBtn = document.getElementById('recordBtn');
    
    // Canvases for processing
    const segmentationCanvas = document.getElementById('segmentation-canvas');
    const segmentationCtx = segmentationCanvas.getContext('2d', { willReadFrequently: true });
    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
    // --- ADDED: High-resolution canvas for a sharper mask ---
    const highResMaskCanvas = document.createElement('canvas');
    const highResMaskCtx = highResMaskCanvas.getContext('2d');


    // State variables
    let shapes = [], currentStream, prevFrameData = null,
        currentFacingMode = 'environment',
        currentShape = 'box',
        worldWidth, worldHeight, grid,
        isProcessing = false,
        lastSegmentationResults = null,
        videoTexture, videoBackgroundPlane, particleGroup,
        mediaRecorder, recordedChunks = [],
        maskPlane, alphaTexture;

    // --- Three.js setup ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000); // Increased far plane
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
    
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.id = 'three-canvas';
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.z = 800;
    controls.maxDistance = 800;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
    controls.update();

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
    directionalLight.position.set(20, 20, 50);
    directionalLight.castShadow = true;
    camera.add(directionalLight);
    scene.add(camera);

    // --- MediaPipe Setup ---
    const selfieSegmentation = new SelfieSegmentation({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`});
    selfieSegmentation.setOptions({ modelSelection: 1 });
    selfieSegmentation.onResults(results => {
        lastSegmentationResults = results;
        isProcessing = false;
    });

    async function processFrame() {
        if (video.readyState < 2 || isProcessing) return;
        isProcessing = true;
        await selfieSegmentation.send({image: video});
    }

    // --- Core functions ---

    function createFloor() {
        grid = new THREE.GridHelper(2000, 200, 0xffffff, 0xffffff); // Increased grid size
        const colors = new Float32Array(grid.geometry.attributes.position.count * 3);
        grid.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        grid.material = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.3 });
        scene.add(grid);
    }

    async function setupCamera(facingMode) {
      if (currentStream) currentStream.getTracks().forEach(track => track.stop());
      try {
        currentStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: facingMode } });
        video.srcObject = currentStream;
        await video.play();
        videoTexture = new THREE.VideoTexture(video);
        
        videoTexture.wrapS = THREE.ClampToEdgeWrapping;
        videoTexture.wrapT = THREE.ClampToEdgeWrapping;

        GRID_DENSITY = 40 - parseInt(densitySlider.value);
        resizeAndInit();
      } catch (e) {
        console.error("Camera setup failed:", e);
        if (facingMode === 'environment') {
            alert('爪 专转  爪, 注专 爪 拽转.');
            currentFacingMode = 'user';
            await setupCamera('user');
        } else {
            alert(' 转 砖转 爪.');
        }
      }
    }
    
    function resizeAndInit() {
      if (!video.videoWidth || !video.videoHeight) return; // Wait for video metadata
      const aspectRatio = video.videoWidth / video.videoHeight;
      if (window.innerWidth / window.innerHeight > aspectRatio) {
        worldHeight = 500;
        worldWidth = worldHeight * aspectRatio;
      } else {
        worldWidth = 500;
        worldHeight = worldWidth / aspectRatio;
      }
      // --- ADDED: Set size for the high-resolution mask canvas ---
      highResMaskCanvas.width = 512;
      highResMaskCanvas.height = 512 / aspectRatio;
      initShapes();
    }

    function createGeometry() {
        const size = GRID_DENSITY * 0.9;
        switch(currentShape) {
            case 'sphere': return new THREE.SphereGeometry(size / 2, 16, 12);
            case 'cone': return new THREE.ConeGeometry(size / 2, size * 1.5, 20);
            case 'torus': return new THREE.TorusGeometry(size * 0.3, size * 0.15, 16, 24);
            case 'cylinder': return new THREE.CylinderGeometry(size / 2, size / 2, SHAPE_DEPTH, 16);
            case 'tetrahedron': return new THREE.TetrahedronGeometry(size * 0.7);
            case 'octahedron': return new THREE.OctahedronGeometry(size * 0.6);
            case 'dodecahedron': return new THREE.DodecahedronGeometry(size * 0.5);
            case 'icosahedron': return new THREE.IcosahedronGeometry(size * 0.6);
            case 'nail':
                const head = new THREE.CylinderGeometry(size * 0.4, size * 0.4, SHAPE_DEPTH * 0.1, 12);
                head.translate(0, SHAPE_DEPTH * 0.5, 0);
                const shaft = new THREE.CylinderGeometry(size * 0.1, size * 0.1, SHAPE_DEPTH, 12);
                const nailGeo = THREE.BufferGeometryUtils.mergeBufferGeometries([head, shaft]);
                nailGeo.rotateX(Math.PI / 2);
                return nailGeo;
            case 'box': default: return new THREE.BoxGeometry(size, size, SHAPE_DEPTH);
        }
    }
    
    function initShapes() {
        if (particleGroup) {
            scene.remove(particleGroup);
        }
        shapes = [];
        particleGroup = new THREE.Group();
        scene.add(particleGroup);

        particleGroup.scale.x = (currentFacingMode === 'user') ? -1 : 1;

        if (videoBackgroundPlane) particleGroup.remove(videoBackgroundPlane);
        if (maskPlane) particleGroup.remove(maskPlane);
        

        const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4, metalness: 0.6 });
        const geometry = createGeometry();
        
        const borderSize = 10;
        const gridW = Math.round(worldWidth / GRID_DENSITY);
        const gridH = Math.round(worldHeight / GRID_DENSITY);
        
        offscreenCanvas.width = gridW;
        offscreenCanvas.height = gridH;
        segmentationCanvas.width = gridW;
        segmentationCanvas.height = gridH;
        
        const totalGridW = gridW + borderSize * 2;
        const totalGridH = gridH + borderSize * 2;
        const totalWorldWidth = totalGridW * GRID_DENSITY;
        const totalWorldHeight = totalGridH * GRID_DENSITY;

        if(grid) grid.position.y = - (totalWorldHeight / 2) - 50;
        
        const planeGeo = new THREE.PlaneGeometry(worldWidth, worldHeight);
        
        const planeMat = new THREE.MeshBasicMaterial({ 
            map: videoTexture,
            side: THREE.FrontSide 
        });
        videoBackgroundPlane = new THREE.Mesh(planeGeo, planeMat);
        videoBackgroundPlane.position.z = 0;
        particleGroup.add(videoBackgroundPlane);

        // --- CHANGED: Use the new high-res canvas for the alpha texture ---
        alphaTexture = new THREE.CanvasTexture(highResMaskCanvas);
        
        const maskMaterial = new THREE.MeshBasicMaterial({
            map: videoTexture,
            alphaMap: alphaTexture,
            transparent: true,
            side: THREE.BackSide
        });
        maskPlane = new THREE.Mesh(planeGeo.clone(), maskMaterial);
        particleGroup.add(maskPlane);


        for (let y = 0; y < totalGridH; y++) {
            for (let x = 0; x < totalGridW; x++) {
                const isVideoShape = (x >= borderSize && x < gridW + borderSize && y >= borderSize && y < gridH + borderSize);
                let originX = (x * GRID_DENSITY) - (totalWorldWidth / 2);
                let originY = -(y * GRID_DENSITY) + (totalWorldHeight / 2);
                
                const shape = new THREE.Mesh(geometry.clone(), material.clone());
                if (!isVideoShape) shape.material.color.set(0x1a1a1a);

                shape.castShadow = true;
                shape.receiveShadow = true;
                shape.position.set(originX, originY, 0);
                shape.userData = { 
                    originPosition: shape.position.clone(), 
                    velocity: new THREE.Vector3(0, 0, 0),
                    rotationalVelocity: new THREE.Vector3(0, 0, 0),
                    originalQuaternion: shape.quaternion.clone(),
                    isVideoShape: isVideoShape
                };

                if (isVideoShape) {
                    const videoX = x - borderSize;
                    const videoY = y - borderSize;
                    shape.userData.dataIndex = (videoY * gridW + videoX) * 4;
                }

                shapes.push(shape);
                particleGroup.add(shape);
            }
        }
        prevFrameData = null;
    }

    function animationLoop() {
      requestAnimationFrame(animationLoop);
      const time = Date.now() * 0.0005;
      
      processFrame();
      
      if(grid) {
        const color1 = new THREE.Color().setHSL(time % 1, 0.7, 0.5);
        const color2 = new THREE.Color().setHSL((time + 0.3) % 1, 0.8, 0.5);
        const colors = grid.geometry.attributes.color.array;
        for (let i = 0; i < colors.length; i += 3) {
            const color = (i % 6 === 0) ? color1 : color2;
            colors[i] = color.r;
            colors[i + 1] = color.g;
            colors[i + 2] = color.b;
        }
        grid.geometry.attributes.color.needsUpdate = true;
      }
      
      if (lastSegmentationResults) updateSceneState();
      updatePhysics();
      controls.update(); // Required for auto-rotation to work
      renderer.render(scene, camera);
    }
    
    function updatePhysics() {
        for (const shape of shapes) {
            const restoreForce = shape.userData.originPosition.clone().sub(shape.position).multiplyScalar(RESTORE_SPEED);
            shape.userData.velocity.add(restoreForce).multiplyScalar(DAMPING);
            shape.position.add(shape.userData.velocity);

            const deltaRotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(shape.userData.rotationalVelocity.x, shape.userData.rotationalVelocity.y, shape.userData.rotationalVelocity.z));
            shape.quaternion.multiplyQuaternions(deltaRotation, shape.quaternion);
            shape.quaternion.slerp(shape.userData.originalQuaternion, RESTORE_SPEED * 2);
            shape.userData.rotationalVelocity.multiplyScalar(ROTATIONAL_DAMPING);
        }
    }

    function updateSceneState() {
        if (!lastSegmentationResults || !alphaTexture) return;

        // --- REPLACED: Logic to create the inverted mask now uses the high-res canvas for a sharp cut ---
        highResMaskCtx.save();
        highResMaskCtx.clearRect(0, 0, highResMaskCanvas.width, highResMaskCanvas.height);
        highResMaskCtx.drawImage(lastSegmentationResults.segmentationMask, 0, 0, highResMaskCanvas.width, highResMaskCanvas.height);
        highResMaskCtx.globalCompositeOperation = 'xor';
        highResMaskCtx.fillStyle = 'white';
        highResMaskCtx.fillRect(0, 0, highResMaskCanvas.width, highResMaskCanvas.height);
        highResMaskCtx.restore();
        alphaTexture.needsUpdate = true;

        // --- This low-res part is for the particles only ---
        segmentationCtx.save();
        segmentationCtx.clearRect(0, 0, segmentationCanvas.width, segmentationCanvas.height);
        segmentationCtx.drawImage(lastSegmentationResults.segmentationMask, 0, 0, segmentationCanvas.width, segmentationCanvas.height);
        segmentationCtx.restore();
        const segmentationData = segmentationCtx.getImageData(0, 0, segmentationCanvas.width, segmentationCanvas.height).data;

        offscreenCtx.save();
        if (currentFacingMode === 'user') {
            offscreenCtx.scale(-1, 1);
            offscreenCtx.translate(-offscreenCanvas.width, 0);
        }
        offscreenCtx.drawImage(video, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
        offscreenCtx.restore();
        const currentFrameData = offscreenCtx.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height).data;

        for (const shape of shapes) {
            if (!shape.userData.isVideoShape) continue;
            
            const dataIndex = shape.userData.dataIndex;
            const isPerson = segmentationData[dataIndex] > 128;

            shape.visible = isPerson;

            if (isPerson) {
                const r = currentFrameData[dataIndex];
                const g = currentFrameData[dataIndex + 1];
                const b = currentFrameData[dataIndex + 2];
                shape.material.color.setRGB(r / 255, g / 255, b / 255);

                if (prevFrameData) {
                    const diff = Math.abs(r - prevFrameData[dataIndex]) + Math.abs(g - prevFrameData[dataIndex+1]) + Math.abs(b - prevFrameData[dataIndex+2]);
                    if (diff > MOTION_THRESHOLD) {
                        shape.userData.velocity.z += EXPLOSION_FORCE;
                        shape.userData.rotationalVelocity.add(new THREE.Vector3((Math.random()-0.5)*ROTATION_FORCE, (Math.random()-0.5)*ROTATION_FORCE, (Math.random()-0.5)*ROTATION_FORCE));
                    }
                }
            }
        }
        prevFrameData = currentFrameData;
    }

    function updateCurrentShapeIcon() {
        const shapeButton = shapeOptions.querySelector(`.shape-btn[data-shape="${currentShape}"]`);
        if (shapeButton) {
            currentShapeBtn.innerHTML = shapeButton.innerHTML;
        }
    }

    // --- Recording Logic ---
    function startRecording() {
        recordedChunks = [];
        const stream = renderer.domElement.captureStream(30); // 30 fps
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });

        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = 'wowow-cam-recording.webm';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        };

        mediaRecorder.start();
        recordBtn.classList.add('recording');
        recordBtn.title = "注爪专 拽";
    }

    function stopRecording() {
        if(mediaRecorder) mediaRecorder.stop();
        recordBtn.classList.remove('recording');
        recordBtn.title = "拽";
    }

    // --- Event Listeners ---
    cameraSwitchBtn.addEventListener('click', () => {
      currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
      setupCamera(currentFacingMode);
    });
    densitySlider.addEventListener('input', () => { GRID_DENSITY = 40 - parseInt(densitySlider.value); resizeAndInit(); });
    forceSlider.addEventListener('input', (e) => EXPLOSION_FORCE = parseFloat(e.target.value));
    depthSlider.addEventListener('input', (e) => { SHAPE_DEPTH = parseFloat(e.target.value); resizeAndInit(); });
    toggleControlsBtn.addEventListener('click', () => mainControls.classList.toggle('hidden'));
    recordBtn.addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            stopRecording();
        } else {
            startRecording();
        }
    });
    
    // Shape selector listeners
    currentShapeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        shapeSelector.classList.toggle('expanded');
    });

    shapeOptions.addEventListener('click', (e) => {
        const button = e.target.closest('.shape-btn');
        if (!button) return;
        currentShape = button.dataset.shape;
        updateCurrentShapeIcon();
        resizeAndInit();
        shapeSelector.classList.remove('expanded');
    });

    window.addEventListener('click', () => {
        if (shapeSelector.classList.contains('expanded')) {
            shapeSelector.classList.remove('expanded');
        }
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        resizeAndInit();
    });

    // --- Initial setup ---
    async function initialize() {
        createFloor();
        updateCurrentShapeIcon();
        await selfieSegmentation.initialize();
        await setupCamera(currentFacingMode);
        animationLoop();
    }
    
    initialize();
  </script>
</body>
</html>
