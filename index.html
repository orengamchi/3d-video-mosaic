<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>פסיפס וידאו תלת-ממדי</title>
  <style>
    /* General page and body styling */
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      overflow: hidden;
      background: #000;
      touch-action: none; /* Disable touch actions like pinch-zoom */
      user-select: none; /* Disable text selection */
      font-family: system-ui, sans-serif;
    }
    /* Canvas and video positioning */
    #three-canvas, video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    video { z-index: 1; opacity: 0; /* Hidden but accessible for processing */ }
    #three-canvas { z-index: 2; background: #000; }
    
    /* Control panel styling */
    .control-panel {
      position: fixed;
      z-index: 10;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(8px);
      padding: 10px 15px;
      border-radius: 15px;
      display: flex;
      gap: 15px;
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    /* Minimalist vertical layout for the main controls */
    #controls {
      top: 20px;
      right: 20px;
      flex-direction: column;
      align-items: stretch;
      width: 240px; /* Increased width for new controls */
      gap: 12px;
    }

    #camera-switch {
      top: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      padding: 0;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      border-radius: 50%;
    }
    #camera-switch:active { background: rgba(0, 0, 0, 0.5); }
    
    /* Form element styling */
    label { font-weight: 500; margin-left: 5px; }
    input, select, button.control-button { 
        cursor: pointer;
        background: rgba(255,255,255,0.1);
        color: white;
        border: 1px solid rgba(255,255,255,0.3);
        border-radius: 5px;
        padding: 5px;
        font-family: system-ui, sans-serif;
        width: 100%;
    }
    select option { background: #333; color: white; }
    
    /* Styling for individual control items */
    .control-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
    }
    .control-item-col {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }
    .control-item input[type="range"] {
        flex-grow: 1;
        margin-right: 10px;
    }
    .control-item select {
        flex-grow: 1;
        margin-right: 10px;
    }
    hr {
        border: none;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        width: 100%;
        margin: 5px 0;
    }
    
    #signature {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: rgba(255, 255, 255, 0.5);
        font-size: 16px;
        z-index: 10;
        pointer-events: none; /* Make it non-interactive */
    }

    /* Class to hide controls */
    .hidable {
        opacity: 1;
        transition: opacity 0.5s ease-in-out;
    }
    .hidden {
        opacity: 0 !important;
        pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- Video element to capture camera stream -->
  <video id="video" autoplay playsinline muted></video>
 
  <!-- Main control panel for effects -->
  <div id="controls" class="control-panel hidable">
    <div class="control-item-col">
        <label for="densitySlider">צפיפות:</label>
        <input type="range" id="densitySlider" min="5" max="35" value="25">
    </div>
    <div class="control-item-col">
        <label for="shapeSelect">צורה:</label>
        <select id="shapeSelect">
            <option value="box">קובייה</option>
            <option value="sphere">כדור</option>
            <option value="hexagon">משושה</option>
            <option value="nail">מסמר</option>
            <option value="cone">חרוט</option>
            <option value="torus">טורוס</option>
        </select>
    </div>
    <div class="control-item-col">
        <label for="forceSlider">תזוזה:</label>
        <input type="range" id="forceSlider" min="1" max="25" value="8" step="0.5">
    </div>
    <div class="control-item-col">
        <label for="depthSlider">עומק:</label>
        <input type="range" id="depthSlider" min="0.1" max="50" value="15" step="0.5">
    </div>
    <hr>
     <div class="control-item-col">
        <label for="colorModeSelect">מצב צבע:</label>
        <select id="colorModeSelect">
            <option value="normal">רגיל</option>
            <option value="grayscale">גווני אפור</option>
            <option value="invert">היפוך צבעים</option>
            <option value="psychedelic">פסיכדלי</option>
        </select>
    </div>
    <div class="control-item-col">
        <label for="backgroundSelect">רקע:</label>
        <select id="backgroundSelect">
            <option value="grid">רצפת רשת</option>
            <option value="black">שחור</option>
            <option value="stars">שדה כוכבים</option>
        </select>
    </div>
    <hr>
    <button id="snapshotBtn" class="control-button">📷 צלם תמונה</button>
    <button id="hideControlsBtn" class="control-button">הסתר תפריט</button>
  </div>
  
  <!-- Button to switch between front and back cameras -->
  <button id="camera-switch" class="control-panel hidable" title="החלף מצלמה">🔄</button>

  <div id="signature" class="hidable">BY Oren Gamchi</div>

  <!-- Third-party libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>


  <script>
    // --- Global constants and variables ---
    let GRID_DENSITY = 20, MOTION_THRESHOLD = 20, EXPLOSION_FORCE = 8, SHAPE_DEPTH = 15;
    const RESTORE_SPEED = 0.03, DAMPING = 0.90;
    const ROTATION_FORCE = 0.2, ROTATIONAL_DAMPING = 0.95;

    // DOM element references
    const video = document.getElementById('video'), cameraSwitchBtn = document.getElementById('camera-switch'),
          densitySlider = document.getElementById('densitySlider'),
          shapeSelect = document.getElementById('shapeSelect'), forceSlider = document.getElementById('forceSlider'),
          depthSlider = document.getElementById('depthSlider'),
          colorModeSelect = document.getElementById('colorModeSelect'),
          backgroundSelect = document.getElementById('backgroundSelect'),
          snapshotBtn = document.getElementById('snapshotBtn'),
          hideControlsBtn = document.getElementById('hideControlsBtn');
   
    // Offscreen canvas for video processing
    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });

    // State variables
    let shapes = [], prevFrameData = null, currentFacingMode = 'environment', currentStream,
        currentShape = 'box', currentColorMode = 'normal', currentBackground = 'grid',
        hideControlsTimeout, worldWidth, worldHeight, grid, stars;

    // --- Three.js setup ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
   
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.id = 'three-canvas';
    document.body.appendChild(renderer.domElement);

    // Orbit controls for camera manipulation
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.z = 400;
    controls.update();

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(20, 20, 50);
    directionalLight.castShadow = true;
    camera.add(directionalLight);
    scene.add(camera);

    // --- Core functions ---

    /**
     * Creates the grid floor.
     */
    function createFloor() {
        grid = new THREE.GridHelper(1000, 100, 0xffffff, 0xffffff);
        grid.material.opacity = 0.3;
        grid.material.transparent = true;
        scene.add(grid);
    }

    /**
     * Creates a starfield background.
     */
    function createStarfield() {
        const starVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = THREE.MathUtils.randFloatSpread(2000);
            const y = THREE.MathUtils.randFloatSpread(2000);
            const z = THREE.MathUtils.randFloatSpread(2000);
            starVertices.push(x, y, z);
        }
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });
        stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
    }

    /**
     * Updates the background based on selection.
     */
    function updateBackground() {
        grid.visible = (currentBackground === 'grid');
        stars.visible = (currentBackground === 'stars');
    }

    /**
     * Sets up the camera stream.
     * @param {string} facingMode - 'user' for front camera, 'environment' for back camera.
     */
    async function setupCamera(facingMode) {
      if (currentStream) currentStream.getTracks().forEach(track => track.stop());
      try {
        currentStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: facingMode } });
        video.srcObject = currentStream;
        video.onloadedmetadata = () => {
          video.play();
          GRID_DENSITY = 40 - parseInt(densitySlider.value);
          resizeAndInit();
        };
      } catch (e) {
        if (facingMode === 'environment') setupCamera('user');
        else alert('לא ניתן לגשת למצלמה.');
      }
    }

    /**
     * Hides all control elements.
     */
    function hideControls() {
        document.querySelectorAll('.hidable').forEach(c => c.classList.add('hidden'));
    }

    /**
     * Shows the controls and resets the auto-hide timer.
     */
    function showAndResetTimer() {
        document.querySelectorAll('.hidable').forEach(c => c.classList.remove('hidden'));
        clearTimeout(hideControlsTimeout);
        hideControlsTimeout = setTimeout(hideControls, 5000);
    }

    /**
     * Recalculates world dimensions based on video aspect ratio and re-initializes shapes.
     */
    function resizeAndInit() {
      const aspectRatio = video.videoWidth / video.videoHeight || 16/9;
      if (window.innerWidth / window.innerHeight > aspectRatio) {
        worldHeight = 500;
        worldWidth = worldHeight * aspectRatio;
      } else {
        worldWidth = 500;
        worldHeight = worldWidth / aspectRatio;
      }
      initShapes();
    }

    /**
     * Creates a geometry based on the current shape selection.
     * @returns {THREE.BufferGeometry} The created geometry.
     */
    function createGeometry() {
        const size = GRID_DENSITY * 0.9;
        switch(currentShape) {
            case 'sphere': return new THREE.SphereGeometry(size / 2, 16, 12);
            case 'cone': return new THREE.ConeGeometry(size / 2, size * 1.5, 20);
            case 'torus': return new THREE.TorusGeometry(size * 0.3, size * 0.15, 16, 24);
            case 'hexagon':
                const hexGeo = new THREE.CylinderGeometry(size / 2, size / 2, SHAPE_DEPTH, 6);
                hexGeo.rotateX(Math.PI / 2);
                return hexGeo;
            case 'nail':
                const head = new THREE.CylinderGeometry(size * 0.4, size * 0.4, SHAPE_DEPTH * 0.1, 12);
                head.translate(0, SHAPE_DEPTH * 0.5, 0);
                const shaft = new THREE.CylinderGeometry(size * 0.1, size * 0.1, SHAPE_DEPTH, 12);
                const nailGeo = THREE.BufferGeometryUtils.mergeBufferGeometries([head, shaft]);
                nailGeo.rotateX(Math.PI / 2);
                return nailGeo;
            case 'box': default: return new THREE.BoxGeometry(size, size, SHAPE_DEPTH);
        }
    }
   
    /**
     * Clears existing shapes and creates a new grid of shapes.
     */
    function initShapes() {
        shapes.forEach(s => { scene.remove(s); s.geometry.dispose(); s.material.dispose(); });
        shapes = [];
        const geometry = createGeometry();
        const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7, metalness: 0.1 });
        
        const borderSize = 10;
        const gridW = Math.round(worldWidth / GRID_DENSITY);
        const gridH = Math.round(worldHeight / GRID_DENSITY);
        offscreenCanvas.width = gridW;
        offscreenCanvas.height = gridH;
        
        const totalGridW = gridW + borderSize * 2;
        const totalGridH = gridH + borderSize * 2;
        const totalWorldWidth = totalGridW * GRID_DENSITY;
        const totalWorldHeight = totalGridH * GRID_DENSITY;

        if (grid) {
            const floorY = - (totalWorldHeight / 2) - 50;
            grid.position.y = floorY;
        }
        
        for (let y = 0; y < totalGridH; y++) {
            for (let x = 0; x < totalGridW; x++) {
                const isVideoShape = (x >= borderSize && x < gridW + borderSize && y >= borderSize && y < gridH + borderSize);
                let originX, originY;
                const isHexGrid = currentShape === 'hexagon';

                if (isHexGrid) {
                    const hexWidth = GRID_DENSITY;
                    const hexHeight = (Math.sqrt(3) / 2) * hexWidth;
                    originX = ((totalGridW - 1 - x) * hexWidth) - (totalWorldWidth / 2);
                    if (y % 2 !== 0) { originX += hexWidth / 2; }
                    originY = -(y * hexHeight) + (totalWorldHeight / 2);
                } else {
                    originX = ((totalGridW - 1 - x) * GRID_DENSITY) - (totalWorldWidth / 2);
                    originY = -(y * GRID_DENSITY) + (totalWorldHeight / 2);
                }
                
                const shapeMaterial = material.clone();
                if (!isVideoShape) {
                    shapeMaterial.color.set(0x1a1a1a);
                }

                const shape = new THREE.Mesh(geometry, shapeMaterial);
                shape.castShadow = true;
                shape.receiveShadow = true;
                shape.position.set(originX, originY, 0);
                shape.userData = { 
                    originPosition: shape.position.clone(), 
                    velocity: new THREE.Vector3(0, 0, 0),
                    rotationalVelocity: new THREE.Vector3(0, 0, 0),
                    originalQuaternion: shape.quaternion.clone(),
                    isVideoShape: isVideoShape
                };

                if (isVideoShape) {
                    const videoX = x - borderSize;
                    const videoY = y - borderSize;
                    shape.userData.dataIndex = (videoY * gridW + videoX) * 4;
                }

                shapes.push(shape);
                scene.add(shape);
            }
        }
        prevFrameData = null;
    }

    /**
     * The main animation loop.
     */
    function animationLoop() {
      requestAnimationFrame(animationLoop);
      const time = Date.now() * 0.0005;
      
      if (grid && grid.visible) {
        const color1 = new THREE.Color().setHSL(time % 1, 0.7, 0.5);
        const color2 = new THREE.Color().setHSL((time + 0.2) % 1, 0.7, 0.5);
        const colors = grid.geometry.attributes.color.array;
        const divisions = 100;
        const center = divisions / 2;
        for (let i = 0, j = 0; i <= divisions; i++) {
            const color = i === center ? color1 : color2;
            color.toArray(colors, j); j += 3; color.toArray(colors, j); j += 3;
        }
        for (let i = 0, j = (divisions + 1) * 6; i <= divisions; i++) {
            const color = i === center ? color1 : color2;
            color.toArray(colors, j); j += 3; color.toArray(colors, j); j += 3;
        }
        grid.geometry.attributes.color.needsUpdate = true;
      }
      
      if (stars && stars.visible) {
          stars.rotation.x = time * 0.05;
          stars.rotation.y = time * 0.05;
      }

      if (video.readyState >= 4) { 
          updateVideoState(time); 
      }
      updatePhysics();
      controls.update();
      renderer.render(scene, camera);
    }
   
    /**
     * Updates the physics for each shape (position and rotation).
     */
    function updatePhysics() {
        for (let i = 0; i < shapes.length; i++) {
            const shape = shapes[i];
            const restoreForce = shape.userData.originPosition.clone().sub(shape.position).multiplyScalar(RESTORE_SPEED);
            shape.userData.velocity.add(restoreForce);
            shape.userData.velocity.multiplyScalar(DAMPING);
            shape.position.add(shape.userData.velocity);
            const deltaRotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(shape.userData.rotationalVelocity.x, shape.userData.rotationalVelocity.y, shape.userData.rotationalVelocity.z));
            shape.quaternion.multiplyQuaternions(deltaRotation, shape.quaternion);
            shape.quaternion.slerp(shape.userData.originalQuaternion, RESTORE_SPEED * 2);
            shape.userData.rotationalVelocity.multiplyScalar(ROTATIONAL_DAMPING);
        }
    }

    /**
     * Processes the video frame, detects motion, and updates shape colors and velocities.
     * @param {number} time - The current animation time for psychedelic effects.
     */
    function updateVideoState(time) {
      offscreenCtx.save();
      if (currentFacingMode === 'user') {
        offscreenCtx.scale(-1, 1);
        offscreenCtx.translate(-offscreenCanvas.width, 0);
      }
      offscreenCtx.drawImage(video, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
      offscreenCtx.restore();

      const currentFrameData = offscreenCtx.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height).data;

      if (prevFrameData && prevFrameData.length === currentFrameData.length) {
        for (let i = 0; i < shapes.length; i++) {
          const shape = shapes[i];
          if (!shape.userData.isVideoShape) continue;

          const dataIndex = shape.userData.dataIndex;
          let r = currentFrameData[dataIndex];
          let g = currentFrameData[dataIndex + 1];
          let b = currentFrameData[dataIndex + 2];

          // Apply color modes
          switch(currentColorMode) {
              case 'grayscale':
                  const avg = (r + g + b) / 3;
                  r = g = b = avg;
                  break;
              case 'invert':
                  r = 255 - r; g = 255 - g; b = 255 - b;
                  break;
              case 'psychedelic':
                  const hue = (time + (dataIndex / 1000)) % 1;
                  const tempColor = new THREE.Color().setHSL(hue, 1, 0.5);
                  r = tempColor.r * 255; g = tempColor.g * 255; b = tempColor.b * 255;
                  break;
          }
          shape.material.color.setRGB(r / 255, g / 255, b / 255);

          const diff = Math.abs(r - prevFrameData[dataIndex]) + Math.abs(g - prevFrameData[dataIndex+1]) + Math.abs(b - prevFrameData[dataIndex+2]);
          if (diff > MOTION_THRESHOLD) {
            shape.userData.velocity.add(new THREE.Vector3(0, 0, -EXPLOSION_FORCE));
            shape.userData.rotationalVelocity.add(new THREE.Vector3((Math.random()-0.5)*ROTATION_FORCE, (Math.random()-0.5)*ROTATION_FORCE, (Math.random()-0.5)*ROTATION_FORCE));
          }
        }
      }
      prevFrameData = currentFrameData;
    }

    // --- Event Listeners ---
    cameraSwitchBtn.addEventListener('click', () => {
      currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
      setupCamera(currentFacingMode);
    });
    densitySlider.addEventListener('input', () => { GRID_DENSITY = 40 - parseInt(densitySlider.value); resizeAndInit(); });
    shapeSelect.addEventListener('change', (e) => { currentShape = e.target.value; resizeAndInit(); });
    forceSlider.addEventListener('input', (e) => EXPLOSION_FORCE = parseFloat(e.target.value));
    depthSlider.addEventListener('input', (e) => { SHAPE_DEPTH = parseFloat(e.target.value); resizeAndInit(); });
    colorModeSelect.addEventListener('change', (e) => currentColorMode = e.target.value);
    backgroundSelect.addEventListener('change', (e) => {
        currentBackground = e.target.value;
        updateBackground();
    });
    snapshotBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = 'wowow-cam-snapshot.png';
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();
    });
    hideControlsBtn.addEventListener('click', hideControls);
    window.addEventListener('pointerdown', showAndResetTimer);
    window.addEventListener('pointermove', showAndResetTimer);
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        resizeAndInit();
    });

    // --- Initial setup ---
    createFloor();
    createStarfield();
    updateBackground();
    setupCamera(currentFacingMode);
    showAndResetTimer();
    animationLoop();
  </script>
</body>
</html>
